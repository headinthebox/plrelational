//
// Copyright (c) 2016 Plausible Labs Cooperative, Inc.
// All rights reserved.
//

class QueryOptimizer {
    var nodes: [QueryPlanner.Node]
    
    private struct NodeOptimizationState {
        var didFilterEquijoin = false
    }
    
    private var optimizationStates: [NodeOptimizationState]
    
    init(nodes: [QueryPlanner.Node]) {
        self.nodes = nodes
        optimizationStates = Array(repeating: .init(), count: nodes.count)
        
        optimize()
    }
    
    fileprivate func optimize() {
        for i in nodes.indices {
            // Don't touch nodes with output callbacks, or we'll screw up outputs.
            if nodes[i].outputCallbacks != nil { continue }
            
            switch nodes[i].op {
                
            case .union where nodes[i].childCount == 1:
                // Unions with a single child (generated by Relation changes) can be eliminated and
                // the child pointed straight at the union's parents.
                let childIndex = nodes[i].childIndexes[0]
                nodes[childIndex].parentIndexes = nodes[i].parentIndexes
                for parentIndex in nodes[i].parentIndexes {
                    nodes[parentIndex].childIndexes.replace(i, with: childIndex)
                }
                nodes[i].parentIndexes = []
                
            case .union where shouldOptimizeNestedUnions(i):
                // Unions whose parents are unions can fold their operands into their parents, reducing
                // the number of layers and the amount of uniquing the query runner has to do.
                for childIndex in nodes[i].childIndexes {
                    nodes[childIndex].parentIndexes.remove(i)
                }
                for parentIndex in nodes[i].parentIndexes {
                    nodes[parentIndex].childIndexes.remove(i)
                    for childIndex in nodes[i].childIndexes {
                        nodes[parentIndex].childIndexes.append(childIndex)
                        nodes[childIndex].parentIndexes.append(parentIndex)
                    }
                }
                nodes[i].parentIndexes = []
                
            case .selectableGenerator(let generatorGetter):
                optimizeSelectableGenerator(i, generatorGetter: generatorGetter)
                
            default:
                break
            }
        }
    }
    
    fileprivate func shouldOptimizeNestedUnions(_ index: Int) -> Bool {
        // We must have at least one child and one parent to perform this optimization. To prevent the optimization from taking too long,
        // limit it to cases where there are at most 10 children and 10 parents. We can only do this optimization when all parents
        // are unions. All parents must also have at most 10 children.
        return
            (1...10).contains(nodes[index].childCount) &&
            (1...10).contains(nodes[index].parentCount) &&
            nodes[index].parentIndexes.all({
                isUnion($0) && (1...10).contains(nodes[$0].childCount)
            })
    }
    
    fileprivate func isUnion(_ index: Int) -> Bool {
        if case .union = nodes[index].op {
            return true
        } else {
            return false
        }
    }
    
    private func optimizeSelectableGenerator(_ index: Int, generatorGetter: @escaping (SelectExpression) -> AnyIterator<Result<Row, RelationError>>) {
        optimizeSelectableGenerator(children: [], cursor: index, height: 0, generatorGetter: generatorGetter)
    }
    
    private func optimizeSelectableGenerator(children: [Int], cursor: Int, height: Int, generatorGetter: @escaping (SelectExpression) -> AnyIterator<Result<Row, RelationError>>) {
        let heightLimit = 10
        if height >= heightLimit {
            return
        }
        
        func recurse(_ generatorGetter: @escaping (SelectExpression) -> AnyIterator<Result<Row, RelationError>>) {
            let newChildren = children + [cursor]
            for parent in nodes[cursor].parentIndexes {
                optimizeSelectableGenerator(children: newChildren, cursor: parent, height: height + 1, generatorGetter: generatorGetter)
            }
        }
        
        switch nodes[cursor].op {
        case .equijoin(let matching):
            addFilterTo(children: children + [cursor], generatorGetter: generatorGetter, equijoin: cursor, equijoinChild: children.last!, matching: matching)
            return
        case .select(let expression):
            addFilterTo(children: children + [cursor], generatorGetter: generatorGetter, selectExpression: expression)
            return
        case .rename(let renaming):
            recurse({
                let renamed = $0.withRenamedAttributes(renaming.inverted)
                return generatorGetter(renamed)
            })
        case .project, .update, .aggregate, .otherwise, .unique:
            // These may make the early filtering invalid, so bail out.
            return
        default:
            recurse(generatorGetter)
        }
    }
    
    private func addFilterTo(children: [Int], generatorGetter: @escaping (SelectExpression) -> AnyIterator<Result<Row, RelationError>>, equijoin: Int, equijoinChild: Int, matching: [Attribute: Attribute]) {
        // We only want to optimize a given equijoin once. If we do it twice, then both sides end up pointing at each other, which
        // can lead to no data being provided, or infinite loops.
        if optimizationStates[equijoin].didFilterEquijoin { return }
        optimizationStates[equijoin].didFilterEquijoin = true
        
        let thisChildIndex = nodes[equijoin].childIndexes.index(of: equijoinChild)!
        let otherChildIndex = 1 - thisChildIndex
        let otherChild = nodes[equijoin].childIndexes[otherChildIndex]
        
        let newMatching = thisChildIndex == 0 ? matching.inverted : matching
        let selectableGenerator = ensureSingleParents(children)
        nodes[selectableGenerator].op = .equijoinedSelectableGenerator(newMatching, generatorGetter)
        nodes[selectableGenerator].childIndexes = [otherChild]
        
        nodes[otherChild].parentIndexes.append(selectableGenerator)
    }
    
    private func addFilterTo(children: [Int], generatorGetter:  @escaping (SelectExpression) -> AnyIterator<Result<Row, RelationError>>, selectExpression: SelectExpression) {
        let selectableGenerator = ensureSingleParents(children)
        nodes[selectableGenerator].op = .rowGenerator({ generatorGetter(selectExpression) })
    }
    
    /// Given a chain of nodes, ensure that all nodes in the chain
    /// have one parent, copying them if necessary. The return value
    /// is the index of the first node in the chain. If no copying
    /// happens then the return value is equal to nodeIndexes[0].
    /// Otherwise it's the index of the newly copied node.
    private func ensureSingleParents(_ nodeIndexes: [Int]) -> Int {
        for i in nodeIndexes.indices.reversed().dropFirst() {
            let nodeIndex = nodeIndexes[i]
            if nodes[nodeIndex].parentCount > 1 {
                return copyNodes(nodeIndexes[0 ... i], lastSingleParent: nodeIndexes[i + 1])
            }
        }
        return nodeIndexes[0]
    }
    
    private func copyNodes(_ nodeIndexes: ArraySlice<Int>, lastSingleParent: Int) -> Int {
        var newNodeIndexes: [Int] = []
        for nodeIndex in nodeIndexes {
            newNodeIndexes.append(nodes.count)
            nodes.append(nodes[nodeIndex])
            optimizationStates.append(.init())
        }
        
        let reversed = zip(newNodeIndexes, nodeIndexes).reversed()
        let paired = zip(reversed, reversed.dropFirst())
        for ((newIndex, oldIndex), (newChildIndex, oldChildIndex)) in paired {
            nodes[newIndex].childIndexes.replace(oldChildIndex, with: newChildIndex)
            nodes[newChildIndex].parentIndexes = [newIndex]
            
            for otherChildIndex in nodes[newIndex].childIndexes where otherChildIndex != newChildIndex {
                nodes[otherChildIndex].parentIndexes.append(newIndex)
            }
            
            // oldIndex isn't used, but it would be terribly confusing to replace it with _
            _ = oldIndex
        }
        nodes[lastSingleParent].childIndexes.replace(nodeIndexes.last!, with: newNodeIndexes.last!)
        nodes[nodeIndexes.last!].parentIndexes.remove(lastSingleParent)
        nodes[newNodeIndexes.last!].parentIndexes = [lastSingleParent]
        
        return newNodeIndexes[0]
    }
}
