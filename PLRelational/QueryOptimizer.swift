//
// Copyright (c) 2016 Plausible Labs Cooperative, Inc.
// All rights reserved.
//

class QueryOptimizer {
    var nodes: [QueryPlanner.Node]
    
    init(nodes: [QueryPlanner.Node]) {
        self.nodes = nodes
        
        optimize()
    }
    
    fileprivate func optimize() {
        for i in nodes.indices {
            // Don't touch nodes with output callbacks, or we'll screw up outputs.
            if nodes[i].outputCallbacks != nil { continue }
            
            switch nodes[i].op {
                
            case .union where nodes[i].childCount == 1:
                // Unions with a single child (generated by Relation changes) can be eliminated and
                // the child pointed straight at the union's parents.
                let childIndex = nodes[i].childIndexes[0]
                nodes[childIndex].parentIndexes = nodes[i].parentIndexes
                for parentIndex in nodes[i].parentIndexes {
                    nodes[parentIndex].childIndexes.replace(i, with: childIndex)
                }
                nodes[i].parentIndexes = []
                
            case .union where shouldOptimizeNestedUnions(i):
                // Unions whose parents are unions can fold their operands into their parents, reducing
                // the number of layers and the amount of uniquing the query runner has to do.
                for childIndex in nodes[i].childIndexes {
                    nodes[childIndex].parentIndexes.remove(i)
                }
                for parentIndex in nodes[i].parentIndexes {
                    nodes[parentIndex].childIndexes.remove(i)
                    for childIndex in nodes[i].childIndexes {
                        nodes[parentIndex].childIndexes.append(childIndex)
                        nodes[childIndex].parentIndexes.append(parentIndex)
                    }
                }
                nodes[i].parentIndexes = []
                
            case .selectableGenerator(let generatorGetter):
                optimizeSelectableGenerator(i, generatorGetter: generatorGetter)
                
            default:
                break
            }
        }
    }
    
    fileprivate func shouldOptimizeNestedUnions(_ index: Int) -> Bool {
        // We must have at least one child and one parent to perform this optimization. To prevent the optimization from taking too long,
        // limit it to cases where there are at most 10 children and 10 parents. We can only do this optimization when all parents
        // are unions. All parents must also have at most 10 children.
        return
            (1...10).contains(nodes[index].childCount) &&
            (1...10).contains(nodes[index].parentCount) &&
            nodes[index].parentIndexes.all({
                isUnion($0) && (1...10).contains(nodes[$0].childCount)
            })
    }
    
    fileprivate func isUnion(_ index: Int) -> Bool {
        if case .union = nodes[index].op {
            return true
        } else {
            return false
        }
    }
    
    private func optimizeSelectableGenerator(_ index: Int, generatorGetter: @escaping (SelectExpression) -> AnyIterator<Result<Row, RelationError>>) {
        if nodes[index].parentCount != 1 {
            return
        }
        
        optimizeSelectableGenerator(index, previousCursor: index, cursor: nodes[index].parentIndexes[0], height: 0, generatorGetter: generatorGetter)
    }
    
    private func optimizeSelectableGenerator(_ index: Int, previousCursor: Int, cursor: Int, height: Int, generatorGetter: @escaping (SelectExpression) -> AnyIterator<Result<Row, RelationError>>) {
        let heightLimit = 10
        if height >= heightLimit {
            return
        }
        
        switch nodes[cursor].op {
        case .equijoin(let matching):
            addFilterTo(selectableGenerator: index, generatorGetter: generatorGetter, equijoin: cursor, equijoinChild: previousCursor, matching: matching)
            return
        case .select(let expression):
            addFilterTo(selectableGenerator: index, generatorGetter: generatorGetter, selectExpression: expression)
            return
        case .project, .rename, .update, .aggregate, .otherwise, .unique:
            // These may make the early filtering invalid, so bail out.
            return
        case _ where nodes[cursor].parentCount != 1:
            return
        default:
            optimizeSelectableGenerator(index, previousCursor: cursor, cursor: nodes[cursor].parentIndexes[0], height: height + 1, generatorGetter: generatorGetter)
        }
    }
    
    private func addFilterTo(selectableGenerator: Int, generatorGetter: @escaping (SelectExpression) -> AnyIterator<Result<Row, RelationError>>, equijoin: Int, equijoinChild: Int, matching: [Attribute: Attribute]) {
        let thisChildIndex = nodes[equijoin].childIndexes.index(of: equijoinChild)!
        let otherChildIndex = 1 - thisChildIndex
        let otherChild = nodes[equijoin].childIndexes[otherChildIndex]
        
        let newMatching = thisChildIndex == 0 ? matching.inverted : matching
        nodes[selectableGenerator].op = .equijoinedSelectableGenerator(newMatching, generatorGetter)
        nodes[selectableGenerator].childIndexes = [otherChild]
        
        nodes[otherChild].parentIndexes.append(selectableGenerator)
    }
    
    private func addFilterTo(selectableGenerator: Int, generatorGetter:  @escaping (SelectExpression) -> AnyIterator<Result<Row, RelationError>>, selectExpression: SelectExpression) {
        nodes[selectableGenerator].op = .rowGenerator({ generatorGetter(selectExpression) })
    }
}
